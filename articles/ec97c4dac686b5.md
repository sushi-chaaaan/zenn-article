---
title: "チーム向けに設定ファイルをパッケージ化して見えたもの"
emoji: "⚙️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [
  "eslint",
  "prettier",
  "typescript",
  "stylelint",
]
published: false
---

:::message
この記事は、2024年4月25日のLTで発表した内容に加筆修正を加えたものです。
[登壇資料はこちらから](https://www.docswell.com/s/sushi-chaaaan/Z24RL4-2024-04-25-progate-lt)
:::

こんにちは、[@sushi-chan](https://zenn.dev/sushichaaaan)です。電気通信大学で学生をしています。

最近、所属する学生団体向けにTypeScriptやWebフロントエンドのプロジェクトでよく利用される以下のツールの設定をパッケージ化しました。

- ESLint
- Prettier
- Stylelint
- TypeScript(tsconfig.json)

@[card](https://github.com/VirtualLiveLab/js-config)

今回はパッケージ化の背景や手法、メリットと実際にやってみて見えたものについて書いていきます。

なお、以下の点はこの記事では触れません。

- それぞれのツールの使い方・設定方法
- パッケージ化した設定ファイルの中身・ルールセット

## 背景

近年、特にWebフロントエンドの文脈においてESLintやTypeScriptの設定はどんどん複雑になっており、ベストプラクティスだと呼ばれる設定も定期的に変わっています。新しいプロジェクトを作成するとき、各種ツールの設定に1時間以上かかってしまうことも珍しくありません。[^1]

[^1]:私が遅いだけな可能性もあります。実際どうなんでしょうね

この設定にかかる労力は開発者を疲弊させるのに十分であり、また初学者がLinterやFormatterを導入する際には、設定ファイルの書き方やルールの意味を理解することがハードルになってしまいます。

今私が所属している団体では開発をメインに活動するチームを立ち上げている最中であり、初学者の割合も高いです。今後このチーム内で複数のプロジェクトを進めていくにあたり、設定にかかる労力の削減と初学者の学習効率の向上のためには設定ファイルのパッケージ化が有効だと考えました。

## 手法

設定ファイルのパッケージ化にはいくつかの手法があります。

- npm packageとして公開する
- GitHub Packagesで公開する
- GitHub上のものを直接インストールしてもらう(`npm install git+...`)

今回は、特別な設定なく利用できる必要があり、特にPrivateにしたりする要素もなかったのでnpm packageとして公開することにしました。

設定を置いているリポジトリでは [pnpm workspace](https://pnpm.io/ja/workspaces) と [changesets](https://github.com/changesets/changesets) を利用しています。4種のツールの設定をまとめておくためにモノレポを利用し、changesetsでパッケージのバージョン管理とリリースを自動化することで管理の労力を減らしています。

## メリット

パッケージ化のメリットとして

- 労力の削減
- チーム内の設定の統一
- プロジェクト固有の設定とそうでない設定の分離

があると考えています。

### 労力の削減・チーム内の設定の統一

まず設定の労力が大きく削減されます。新しいプロジェクトを作成する際にやることは、ツールそのものと設定パッケージをインストールしたあと、内蔵されているプリセットを組み合わせるだけです。

ESLintを例に説明すると、パッケージ化前は

```bash
npm install --save-dev eslint eslint-config-hogehoge \
  ...以下多数のESLint関連パッケージ
```

だったものが

```bash
npm install --save-dev eslint @virtual-live-lab/eslint-config
```

だけで済むようになり、どの設定パッケージがどのルールに対応しているかを覚えておく必要もなくなりました。

あとは、プロジェクトに合わせたプリセットを組み合わせるだけです。

```js title:eslint.config.mjs
import react from "@virtual-live-lab/eslint-config/presets/react";
import tailwind from "@virtual-live-lab/eslint-config/addons/tailwind";
import tseslint from "typescript-eslint";

// React + TypeScript + TailwindCSSの例
export default tseslint.config(...react, ...tailwind);
```

また、この手順を踏むことでチーム内での設定の統一が自動的に達成できます。設定ファイルの内容を変更する際は、パッケージのバージョンを上げるだけでチーム全体に反映されるため差異が生じることがありません。
ツールのバージョンアップに伴う破壊的変更も、設定ファイル側の`peerDependencies`を変更すれば安全に対応できます。

### プロジェクト固有の設定とそうでない設定の分離

これは実際にやるまでわからなかったメリットで、`tsconfig.json`で顕著に見られました。

`compilerOptions`の大半は使うフレームワークや環境ごとに決まっているので、それらをプリセットに入れることで`tsconfig.json`に具体的に書く設定はpath aliasやプロジェクト全体で有効にする型定義、`include`や`exclude`などプロジェクト固有の設定に絞られました。

```json title:tsconfig.json
{
  // Next.jsをCloudflare Pagesにデプロイする場合の例
  "extends": "@virtual-live-lab/tsconfig/nextjs",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
    },
    "types": ["vitest/globals", "@cloudflare/workers-types"]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
  ],
}

```

## 注意するべき点

とはいえ、ただパッケージ化すればいいというものではなく、いくつか注意するべき点があります。
